import React, { useState, useEffect, useRef, useMemo, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import * as XLSX from 'xlsx';
import PhotoUpload from './PhotoUpload';
import './FireDoorSurveyForm.css';
import axios from 'axios';
import SurveyTracker from './SurveyTracker';
import ExcelJS from 'exceljs';
import RoomTypeSelector from './RoomTypeSelector';
import LocationSelector from './LocationSelector';
import { updateSurvey, createSurvey, fetchSurveys, uploadSurveyPhoto } from '../api/surveyApi';

const API_BASE_URL = 'http://localhost:5001';

const PHOTO_TYPES = {
  FRONT_DOOR: 'frontDoorPicture',
  TOP_LEAF: 'topLeafPicture',
  TOP_LEAF_DOUBLE: 'topLeafDoublePicture',
  FAULTS_3: 'unmentionedFaults3',
  FAULTS_4: 'unmentionedFaults4',
  FAULTS_5: 'unmentionedFaults5'
};

const commonThicknessValues = ['44', '54', '58'];

// Add new GapMeasurementAccordion component
const GapMeasurementAccordion = React.memo(({ 
  type, 
  label, 
  gapData, 
  onGapChange, 
  onPhotoUpload, 
  photoUrl, 
  onPhotoRemove,
  isExpanded,
  onToggle,
  onRangeComplete,
  isCompliant
}) => {
  const [isManualInput, setIsManualInput] = useState(false);
  const [longPressTimer, setLongPressTimer] = useState(null);
  const [isSelectingRange, setIsSelectingRange] = useState(false);
  const accordionRef = useRef(null);

  const handleManualRangeSubmit = (e) => {
    e.preventDefault();
    const start = e.target.rangeStart.value;
    const end = e.target.rangeEnd.value;
    if (start && end && parseFloat(start) < parseFloat(end)) {
      onGapChange(type, start, true);
      onGapChange(type, end, false);
    }
  };

  const handleButtonMouseDown = useCallback(() => {
    const timer = setTimeout(() => {
      setIsSelectingRange(true);
    }, 500);
    setLongPressTimer(timer);
  }, []);

  const handleButtonMouseUp = useCallback(() => {
    if (longPressTimer) {
      clearTimeout(longPressTimer);
      setLongPressTimer(null);
    }
    setIsSelectingRange(false);
  }, [longPressTimer]);

  const handleButtonClick = useCallback((value) => {
    if (!isSelectingRange) {
      if (!gapData.start) {
        onGapChange(type, value, true);
      } else if (!gapData.end && parseFloat(value) > parseFloat(gapData.start)) {
        onGapChange(type, value, false);
        onRangeComplete(type);
      } else {
        onGapChange(type, value, true);
        onGapChange(type, '', false);
      }
    }
  }, [isSelectingRange, gapData, onGapChange, onRangeComplete, type]);

  const getRangeSummary = useCallback(() => {
    if (gapData.start && gapData.end) {
      return `${gapData.start} ‚Äì ${gapData.end} mm`;
    } else if (gapData.start) {
      return `${gapData.start} mm`;
    }
    return 'Not set';
  }, [gapData.start, gapData.end]);

  const isWithinCompliantRange = useCallback((value) => {
    const numValue = parseFloat(value);
    return numValue >= 2 && numValue <= 4;
  }, []);

  const gapButtons = useMemo(() => {
    return ['0', '1', '2', '3', '4', '4.5', '5', '6', '7', '8', '9', '10', '11', '12+'].map(value => (
      <button
        key={value}
        className={`gap-button ${gapData.start === value ? 'selected start' : ''} 
          ${gapData.end === value ? 'selected end' : ''} 
          ${gapData.start && gapData.end && 
          parseFloat(value) > parseFloat(gapData.start) && 
          parseFloat(value) < parseFloat(gapData.end) ? 'in-range' : ''}
          ${isWithinCompliantRange(value) ? 'compliant' : ''}`}
        onClick={() => handleButtonClick(value)}
        onMouseDown={handleButtonMouseDown}
        onMouseUp={handleButtonMouseUp}
        onTouchStart={handleButtonMouseDown}
        onTouchEnd={handleButtonMouseUp}
      >
        {value}
      </button>
    ));
  }, [gapData.start, gapData.end, isWithinCompliantRange, handleButtonClick, handleButtonMouseDown, handleButtonMouseUp]);

  return (
    <div className={`gap-accordion ${isExpanded ? 'expanded' : ''}`} ref={accordionRef}>
      <div 
        className={`gap-accordion-header ${isCompliant ? 'compliant' : ''}`}
        onClick={onToggle}
      >
        <div className="gap-header-content">
          <span className="gap-label">{label}</span>
          <span className="gap-summary">{getRangeSummary()}</span>
          {isCompliant && <span className="compliant-check">‚úì</span>}
        </div>
        <div className="gap-header-actions">
          <label className="photo-upload-mini">
            <input
              type="file"
              accept="image/*"
              onChange={onPhotoUpload}
              style={{ display: 'none' }}
            />
            <span className="camera-icon">üì∏</span>
          </label>
          <span className="accordion-arrow">{isExpanded ? '‚ñº' : '‚ñ∂'}</span>
        </div>
      </div>

      {isExpanded && (
        <div className="gap-accordion-content">
          <div className="input-type-toggle">
            <button
              type="button"
              className={`toggle-button ${!isManualInput ? 'active' : ''}`}
              onClick={() => setIsManualInput(false)}
            >
              Buttons
            </button>
            <button
              type="button"
              className={`toggle-button ${isManualInput ? 'active' : ''}`}
              onClick={() => setIsManualInput(true)}
            >
              Manual
            </button>
          </div>

          {isManualInput ? (
            <form onSubmit={handleManualRangeSubmit} className="manual-range-form">
              <div className="range-inputs">
                <input
                  type="number"
                  name="rangeStart"
                  placeholder="Start"
                  step="0.5"
                  min="0"
                  max="12"
                />
                <span>to</span>
                <input
                  type="number"
                  name="rangeEnd"
                  placeholder="End"
                  step="0.5"
                  min="0"
                  max="12"
                />
                <button type="submit">Set</button>
              </div>
            </form>
          ) : (
            <div className="gap-buttons">
              {gapButtons}
            </div>
          )}

          {photoUrl && (
            <div className="photo-preview-mini">
              <img src={photoUrl} alt={`${label} measurement`} />
              <button className="remove-photo" onClick={() => onPhotoRemove(type)}>‚úï</button>
            </div>
          )}
        </div>
      )}
    </div>
  );
});

const FireDoorSurveyForm = () => {
  const navigate = useNavigate();
  const [formData, setFormData] = useState({
    doorPinNo: 1,
    floor: '',
    room: '',
    locationOfDoorSet: '',
    doorType: '',
    doorConfiguration: {
      type: '',
      hasFanLight: false,
      hasSidePanels: false,
      hasVPPanel: false  // Add new state for VP Panel
    },
    doorMaterial: {
      type: '',
      customType: ''
    },
    rating: 'FD30s',
    thirdPartyCertification: {
      type: '',
      customText: '',
      photo: null,
      photoUrl: null
    },
    surveyed: '',
    surveyedReason: '', // Add new state for the reason
    surveyedCustomReason: '', // Add new state for custom reason
    isFlagged: false,
    leafGap: {
      hingeSide: {
        start: '',
        end: ''
      },
      topGap: {
        start: '',
        end: ''
      },
      leadingEdge: {
        start: '',
        end: ''
      }
    },
    thresholdGap: '',
    showExtendedThresholdGap: false,
    measurements: {
      hingeSidePhoto: null,
      hingeSidePhotoUrl: null,
      topGapPhoto: null,
      topGapPhotoUrl: null,
      leadingEdgePhoto: null,
      leadingEdgePhotoUrl: null,
      thresholdGapPhoto: null,
      thresholdGapPhotoUrl: null,
      leafThicknessPhoto: null,
      leafThicknessPhotoUrl: null
    },
    leafThickness: '',
    combinedStripsCondition: '',
    combinedStripsDefect: '',
    selfCloserFunctional: '',
    selfCloserDefect: '',
    selfCloserCustomDefect: '',
    hingesCondition: '',
    hingesDefect: '',
    hingesCustomDefect: '',
    frameCondition: '',
    frameDefect: '',
    frameCustomDefect: '',
    handlesSufficient: '',
    handlesDefect: '',
    handlesCustomDefect: '',
    signageSatisfactory: '',
    signageDefect: '',
    signageCustomDefect: '',
    doorGuardWorking: '',
    glazingSufficient: '',
    glazingDefect: '',
    glazingCustomDefect: '',
    glazingBeading: '',
    glazing30Minutes: '',
    fanLightsSufficient: '',
    fanLightsDefect: '',
    fanLightsCustomDefect: '',
    headerPanelsSufficient: '',
    upgradeReplacement: '',
    overallCondition: '',
    addDetail: '',
    conditionDetails: {
      leafGap: '',
      thresholdGap: '',
      notes: ''
    },
    customSection: {
      label: '',
      value: '',
      defect: '',
      customDefect: '',
      componentName: '',
      description: ''
    },
    defectPhotos: {
      frame: null,
      handles: null,
      signage: null,
      selfCloser: null,
      hinges: null,
      glazing: null,
      fanLights: null,
      combinedStrips: null,
      customSection: null
    },
    combinedStripsPhoto: null,
    combinedStripsPhotoUrl: null,
    roomType: ''
  });
  const [surveyId, setSurveyId] = useState(null);
  const [isSurveySaved, setIsSurveySaved] = useState(false);
  const [drawingFile, setDrawingFile] = useState(null);
  const [hasSkippedDrawing, setHasSkippedDrawing] = useState(false);
  const [uploadedPhotos, setUploadedPhotos] = useState(
    Object.values(PHOTO_TYPES).reduce((acc, type) => ({ ...acc, [type]: false }), {})
  );
  const [notifications, setNotifications] = useState([]);
  const [tempPhotos, setTempPhotos] = useState({});
  const [validationErrors, setValidationErrors] = useState({});
  const [error, setError] = useState('');
  const [showNotifications, setShowNotifications] = useState(false);
  const [currentNotificationIndex, setCurrentNotificationIndex] = useState(0);
  const [allSurveys, setAllSurveys] = useState([]);
  const [currentDoor, setCurrentDoor] = useState(1);
  const [surveyedDoorsList, setSurveyedDoorsList] = useState([]);
  const [isEditing, setIsEditing] = useState(false);
  const [showMeasurements, setShowMeasurements] = useState(false);
  const [expandedGap, setExpandedGap] = useState('hingeSide');
  const [isSaving, setIsSaving] = useState(false);

  // Add word sets for the phrase builder
  const WORD_SETS = {
    initial: [
      'Next to',
      'Opposite',
      'Adjacent to',
      'Inside',
      'Outside',
      'Between',
      'Near',
      'At',
      'Leading into',
      'Close to',
      'In front of',
      'Behind'
    ],
    places: [
      'Flat',
      'Corridor',
      'Bedroom',
      'Stairs',
      'Lobby',
      'Kitchen',
      'Toilet',
      'Plant Room',
      'Cluster Entrance',
      'Lift',
      'Main Entrance',
      'Fire Exit',
      'Riser',
      'Electrical Riser',
      'Water Riser'
    ]
  };

  const [currentWordSet, setCurrentWordSet] = useState('initial');
  const [customWords, setCustomWords] = useState({ initial: [], places: [] });
  const [isAddingWord, setIsAddingWord] = useState(false);
  const [newWord, setNewWord] = useState('');

  const handleAddCustomWord = () => {
    if (newWord.trim()) {
      setCustomWords(prev => ({
        ...prev,
        [currentWordSet]: [...prev[currentWordSet], newWord.trim()]
      }));
      setNewWord('');
      setIsAddingWord(false);
    }
  };

  const handleLocationOption = (option) => {
    // If it's the '+' button, show input for new word
    if (option === '+') {
      setIsAddingWord(true);
      return;
    }
    
    let newLocation = formData.locationOfDoorSet;
    
    // Add space before the option if there's already text
    if (newLocation && !newLocation.endsWith(' ')) {
      newLocation += ' ';
    }
    
    // Add the option
    newLocation += option;
    
    // Add space after the option
    if (!newLocation.endsWith(' ')) {
      newLocation += ' ';
    }
    
    handleInputChange('locationOfDoorSet', newLocation);

    // After selecting from initial set, show places set
    if (currentWordSet === 'initial') {
      setCurrentWordSet('places');
      setIsAddingWord(false);
    }
  };

  useEffect(() => {
    const savedNotifications = localStorage.getItem('doorNotifications');
    if (savedNotifications) {
      setNotifications(JSON.parse(savedNotifications));
    }
  }, []);

  useEffect(() => {
    const fetchSurveys = async () => {
      try {
        const response = await axios.get(`${API_BASE_URL}/api/surveys`);
        const surveys = response.data;
        setAllSurveys(surveys);
        // Extract surveyed door numbers with their flag status
        const doorNumbers = surveys.map(survey => ({
          doorNumber: survey.doorNumber,
          isFlagged: survey.isFlagged || false
        }));
        setSurveyedDoorsList(doorNumbers);
      } catch (error) {
        console.error('Error fetching surveys:', error);
        setError('Failed to fetch surveys');
      }
    };

    fetchSurveys();
  }, []);

  const validateField = (field, value, section = null) => {
    let error = '';
    const fieldValue = section ? value[field] : value;

    switch (field) {
      case 'rating':
        if (!fieldValue) {
          error = 'Fire Resistance Rating is required';
        }
        break;
      case 'doorType':
        if (!fieldValue) {
          error = 'Door Type is required';
        }
        break;
      case 'surveyed':
        if (!fieldValue) {
          error = 'Accessed field is required';
        }
        break;
      case 'selfCloserDefect':
        if (formData.selfCloserFunctional === 'No' && !fieldValue) {
          error = 'Please select a defect type';
        }
        break;
      case 'selfCloserCustomDefect':
        if (formData.selfCloserFunctional === 'No' && formData.selfCloserDefect === 'custom' && !fieldValue?.trim()) {
          error = 'Please specify the custom defect';
        }
        break;
      case 'hingesDefect':
        if (formData.hingesCondition === 'No' && !fieldValue) {
          error = 'Please select a defect type';
        }
        break;
      case 'hingesCustomDefect':
        if (formData.hingesCondition === 'No' && formData.hingesDefect === 'custom' && !fieldValue?.trim()) {
          error = 'Please specify the custom defect';
        }
        break;
      case 'glazingDefect':
        if (formData.glazingSufficient === 'No' && !fieldValue) {
          error = 'Please select a defect type';
        }
        break;
      case 'glazingCustomDefect':
        if (formData.glazingSufficient === 'No' && formData.glazingDefect === 'custom' && !fieldValue?.trim()) {
          error = 'Please specify the custom defect';
        }
        break;
      case 'fanLightsDefect':
        if (formData.fanLightsSufficient === 'No' && !fieldValue) {
          error = 'Please select a defect type';
        }
        break;
      case 'fanLightsCustomDefect':
        if (formData.fanLightsSufficient === 'No' && formData.fanLightsDefect === 'custom' && !fieldValue?.trim()) {
          error = 'Please specify the custom defect';
        }
        break;
      case 'frameDefect':
        if (formData.frameCondition === 'N' && !fieldValue) {
          error = 'Please select a defect type';
        }
        break;
      case 'frameCustomDefect':
        if (formData.frameCondition === 'N' && formData.frameDefect === 'custom' && !fieldValue?.trim()) {
          error = 'Please specify the custom defect';
        }
        break;
      case 'handlesDefect':
        if (formData.handlesSufficient === 'N' && !fieldValue) {
          error = 'Please select a defect type';
        }
        break;
      case 'handlesCustomDefect':
        if (formData.handlesSufficient === 'N' && formData.handlesDefect === 'custom' && !fieldValue?.trim()) {
          error = 'Please specify the custom defect';
        }
        break;
      case 'signageDefect':
        if (formData.signageSatisfactory === 'N' && !fieldValue) {
          error = 'Please select a defect type';
        }
        break;
      case 'signageCustomDefect':
        if (formData.signageSatisfactory === 'N' && formData.signageDefect === 'custom' && !fieldValue?.trim()) {
          error = 'Please specify the custom defect';
        }
        break;
      case 'upgradeReplacement':
        if (!fieldValue) {
          error = 'Upgrade/Replacement field is required';
        }
        break;
      case 'overallCondition':
        if (!fieldValue) {
          error = 'Overall Condition is required';
        }
        break;
          break;
    }

    return error;
  };

  const handleInputChange = (field, value, section = null) => {
    setError('');
    if (section) {
      setFormData(prev => ({
        ...prev,
        [section]: {
          ...prev[section],
          [field]: value
        }
      }));
    } else {
      // Special handling for rating changes
      if (field === 'rating') {
        const isNonFireRated = ['Not Fire-Rated', 'Notional', 'Nominal'].includes(value);
        setFormData(prev => ({
          ...prev,
          [field]: value,
          // Automatically set Third Party Certification for non-fire-rated doors
          thirdPartyCertification: {
            ...prev.thirdPartyCertification,
            type: isNonFireRated ? 'na' : prev.thirdPartyCertification.type,
            customText: isNonFireRated ? '' : prev.thirdPartyCertification.customText
          }
        }));
      } else {
        setFormData(prev => ({
      ...prev,
          [field]: value
    }));
      }
    }
    validateField(field, value, section);
  };

  const handleOptionClick = (field, value) => {
    setFormData(prev => ({ ...prev, [field]: value }));
    setError('');
  };   

  const handleDrawingUpload = async (event) => {
    const file = event.target.files[0];
    if (file) {
      setDrawingFile(file);
      setHasSkippedDrawing(false);
    }
  };

  const handleSkipDrawing = () => {
    setHasSkippedDrawing(true);
    setDrawingFile(null);
  };

  const handlePhotoUpload = async (photoType, file) => {
    if (!surveyId) {
      setTempPhotos(prev => ({ ...prev, [photoType]: file }));
      setUploadedPhotos(prev => ({ ...prev, [photoType]: true }));
      return;
    }

    try {
      const formData = new FormData();
      formData.append('photo', file);
      formData.append('photoType', photoType);

      const response = await fetch(`${API_BASE_URL}/api/surveys/${surveyId}/photos`, {
        method: 'POST',
        body: formData,
      });

      if (!response.ok) {
        throw new Error('Failed to upload photo');
      }

      setUploadedPhotos(prev => ({ ...prev, [photoType]: true }));
      setError('Photo uploaded successfully!');
    } catch (error) {
      console.error('Error uploading photo:', error);
      setError('Failed to upload photo. Please try again.');
    }
  };

  const uploadTempPhotos = async (newSurveyId) => {
    for (const [photoType, file] of Object.entries(tempPhotos)) {
      try {
        const formData = new FormData();
        formData.append('photo', file);
        formData.append('photoType', photoType);

        const response = await fetch(`${API_BASE_URL}/api/surveys/${newSurveyId}/photos`, {
          method: 'POST',
          body: formData,
        });

        if (!response.ok) {
          console.error(`Failed to upload temporary photo ${photoType}`);
        }
      } catch (error) {
        console.error(`Error uploading temporary photo ${photoType}:`, error);
      }
    }
    setTempPhotos({});
  };

  const handleLeafGapChange = (type, value, isStart) => {
    setFormData(prev => {
      const currentGap = prev.leafGap[type];
      let newStart = currentGap.start;
      let newEnd = currentGap.end;

      // Convert values to numbers for comparison
      const numValue = parseFloat(value);
      const numStart = parseFloat(currentGap.start);
      const numEnd = parseFloat(currentGap.end);

      if (isStart) {
        // If setting start value
        newStart = value;
        // If end is set and new start is greater than end, clear end
        if (newEnd && numValue > parseFloat(newEnd)) {
          newEnd = '';
        }
      } else {
        // If setting end value
        newEnd = value;
        // If start is set and new end is less than start, clear start
        if (newStart && numValue < parseFloat(newStart)) {
          newStart = '';
        }
      }

      return {
        ...prev,
        leafGap: {
          ...prev.leafGap,
          [type]: {
            start: newStart,
            end: newEnd
          }
        }
      };
    });
  };

  const handleHingeSidePhotoUpload = (event) => {
    const file = event.target.files[0];
    if (file) {
      setFormData(prev => ({
        ...prev,
        measurements: {
          ...prev.measurements,
          hingeSidePhoto: file,
          hingeSidePhotoUrl: URL.createObjectURL(file)
        }
      }));
    }
  };

  const handleTopGapPhotoUpload = (event) => {
    const file = event.target.files[0];
    if (file) {
      setFormData(prev => ({
        ...prev,
        measurements: {
          ...prev.measurements,
          topGapPhoto: file,
          topGapPhotoUrl: URL.createObjectURL(file)
        }
      }));
    }
  };

  const handleLeadingEdgePhotoUpload = (event) => {
    const file = event.target.files[0];
    if (file) {
      setFormData(prev => ({
        ...prev,
        measurements: {
          ...prev.measurements,
          leadingEdgePhoto: file,
          leadingEdgePhotoUrl: URL.createObjectURL(file)
        }
      }));
    }
  };

  const handleSurveyedChange = (value) => {
    handleOptionClick('surveyed', value);
    
    // Clear reason if Y is selected
    if (value === 'Y') {
      setFormData(prev => ({
        ...prev,
        surveyedReason: '',
        surveyedCustomReason: ''
      }));
    }
    
    if (value === 'N') {
      const newNotification = {
        doorNumber: formData.doorPinNo || 1,
        location: formData.locationOfDoorSet || 'Unknown location',
        floor: formData.floor || '',
        room: formData.room || '',
        date: new Date().toISOString()
      };
      
      setNotifications(prev => {
        const updated = [...prev, newNotification];
        localStorage.setItem('doorNotifications', JSON.stringify(updated));
        return updated;
      });
    }
  };

  const handleSurveyedReasonChange = (reason) => {
    setFormData(prev => ({
      ...prev,
      surveyedReason: reason,
      surveyedCustomReason: '' // Clear custom reason when selecting predefined reason
    }));
  };

  const handleSurveyedCustomReasonChange = (value) => {
    setFormData(prev => ({
      ...prev,
      surveyedReason: 'custom',
      surveyedCustomReason: value
    }));
  };

  const validateForm = useCallback(() => {
    const errors = {};
    
    // Validate required fields
    if (!formData.doorPinNo) {
      errors.doorPinNo = 'Door Number is required';
    }
    
    if (!formData.doorConfiguration.type) {
      errors.doorConfiguration = 'Door Configuration is required';
    }
    
    if (!formData.rating) {
      errors.rating = 'Fire Rating is required';
    }
    
    if (!formData.surveyed) {
      errors.surveyed = 'Accessed field is required';
    }

    // If surveyed is "N", a reason is required
    if (formData.surveyed === 'N' && !formData.surveyedReason) {
      errors.surveyedReason = 'Please select a reason for not accessing';
    }

    // If custom reason is selected, text is required
    if (formData.surveyedReason === 'custom' && !formData.surveyedCustomReason.trim()) {
      errors.surveyedCustomReason = 'Please provide a custom reason';
    }

    if (!formData.upgradeReplacement) {
      errors.upgradeReplacement = 'Upgrade/Replacement field is required';
    }

    if (!formData.overallCondition) {
      errors.overallCondition = 'Overall Condition is required';
    }
    
    // Update validation errors state
    setValidationErrors(errors);
    
    // Return true if no errors
    return Object.keys(errors).length === 0;
  }, [
    formData.doorPinNo, 
    formData.doorConfiguration.type, 
    formData.rating, 
    formData.surveyed, 
    formData.surveyedReason, 
    formData.surveyedCustomReason,
    formData.upgradeReplacement, 
    formData.overallCondition
  ]);

  const loadSurveyData = useCallback(async (doorNumber) => {
    try {
      // Find the door in the existing lists (optimized lookup)
      const doorInList = surveyedDoorsList.find(
        door => door.doorNumber === doorNumber.toString()
      );
      
      const survey = allSurveys.find(s => s.doorNumber === doorNumber.toString());
      
      if (survey) {
        // Batch state updates for existing survey
        const updatedFormData = {
          ...formData,
          doorPinNo: parseInt(survey.doorNumber),
          floor: survey.floor || '',
          room: survey.room || '',
          locationOfDoorSet: survey.locationOfDoorSet || '',
          doorType: survey.doorType || '',
          rating: survey.rating || 'FD30s',
          thirdPartyCertification: {
            ...formData.thirdPartyCertification,
            type: survey.thirdPartyCertification?.type || '',
            customText: survey.thirdPartyCertification?.customText || '',
            photo: survey.thirdPartyCertification?.photo || null,
            photoUrl: survey.thirdPartyCertification?.photoUrl || null
          },
          surveyed: survey.surveyed || '',
          surveyedReason: survey.surveyedReason || '',
          surveyedCustomReason: survey.surveyedCustomReason || '',
          leafGap: {
            hingeSide: survey.leafGap?.hingeSide || {start: '', end: ''},
            topGap: survey.leafGap?.topGap || {start: '', end: ''},
            leadingEdge: survey.leafGap?.leadingEdge || {start: '', end: ''}
          },
          thresholdGap: survey.thresholdGap || '',
          combinedStripsCondition: survey.combinedStripsCondition || '',
          selfCloserFunctional: survey.selfCloserFunctional || '',
          hingesCondition: survey.hingesCondition || '',
          glazingSufficient: survey.glazingSufficient || '',
          fanLightsSufficient: survey.fanLightsSufficient || '',
          upgradeReplacement: survey.upgradeReplacement || '',
          overallCondition: survey.overallCondition || '',
          conditionDetails: {
            ...formData.conditionDetails,
            notes: survey.notes || ''
          },
          isFlagged: Boolean(survey.isFlagged)
        };
        
        // Update multiple states efficiently
        setIsEditing(true);
        setSurveyId(survey._id);
        setIsSurveySaved(true);
        setFormData(updatedFormData);
        setError('Survey loaded for editing');
      } else {
        // Handle new survey efficiently
        const isFlaggedInList = doorInList?.isFlagged === true;
        
        // Reset completely for new survey
        const resetData = resetForm();
        setIsEditing(false);
        setSurveyId(null);
        setIsSurveySaved(false);
        setFormData({
          ...resetData,
          doorPinNo: doorNumber,
          isFlagged: isFlaggedInList
        });
      }
    } catch (error) {
      setError('Failed to load survey data');
    }
  }, [allSurveys, surveyedDoorsList, formData, resetForm]);

  const handleDoorChange = async (doorNumber) => {
    if (doorNumber < 1) return;
    await loadSurveyData(doorNumber);
    setCurrentDoor(doorNumber);
  };

  const resetForm = () => {
    // Store current door number
    const currentDoorNumber = formData.doorPinNo;

    // When we reset the form, we want to:
    // 1. Clear all fields for a new survey
    // 2. Start with a clean isFlagged state (false)
    const resetData = {
      doorPinNo: currentDoorNumber,
      floor: '',
      room: '',
      locationOfDoorSet: '',
      doorType: '',
      doorConfiguration: {
        type: '',
        hasFanLight: false,
        hasSidePanels: false,
        hasVPPanel: false
      },
      doorMaterial: {
        type: '',
        customType: ''
      },
      rating: 'FD30s',
      thirdPartyCertification: {
        type: '',
        customText: '',
        photo: null,
        photoUrl: null
      },
      surveyed: '',
      surveyedReason: '',
      surveyedCustomReason: '',
      isFlagged: false, // Always start a new form as unflagged
      leafGap: {
        hingeSide: {
          start: '',
          end: ''
        },
        topGap: {
          start: '',
          end: ''
        },
        leadingEdge: {
          start: '',
          end: ''
        }
      },
      thresholdGap: '',
      showExtendedThresholdGap: false,
      measurements: {
        hingeSidePhoto: null,
        hingeSidePhotoUrl: null,
        topGapPhoto: null,
        topGapPhotoUrl: null,
        leadingEdgePhoto: null,
        leadingEdgePhotoUrl: null,
        thresholdGapPhoto: null,
        thresholdGapPhotoUrl: null,
        leafThicknessPhoto: null,
        leafThicknessPhotoUrl: null
      },
      leafThickness: '',
      combinedStripsCondition: '',
      combinedStripsDefect: '',
      selfCloserFunctional: '',
      selfCloserDefect: '',
      selfCloserCustomDefect: '',
      hingesCondition: '',
      hingesDefect: '',
      hingesCustomDefect: '',
      frameCondition: '',
      frameDefect: '',
      frameCustomDefect: '',
      handlesSufficient: '',
      handlesDefect: '',
      handlesCustomDefect: '',
      signageSatisfactory: '',
      signageDefect: '',
      signageCustomDefect: '',
      doorGuardWorking: '',
      glazingSufficient: '',
      glazingDefect: '',
      glazingCustomDefect: '',
      glazingBeading: '',
      glazing30Minutes: '',
      fanLightsSufficient: '',
      fanLightsDefect: '',
      fanLightsCustomDefect: '',
      headerPanelsSufficient: '',
      upgradeReplacement: '',
      overallCondition: '',
      addDetail: '',
      conditionDetails: {
        leafGap: '',
        thresholdGap: '',
        notes: ''
      },
      customSection: {
        label: '',
        value: '',
        defect: '',
        customDefect: '',
        componentName: '',
        description: ''
      },
      defectPhotos: {
        frame: null,
        handles: null,
        signage: null,
        selfCloser: null,
        hinges: null,
        glazing: null,
        fanLights: null,
        combinedStrips: null,
        customSection: null
      },
      combinedStripsPhoto: null,
      combinedStripsPhotoUrl: null,
      roomType: ''
    };

    // Reset the state
    setFormData(resetData);
    setIsEditing(false);
    setSurveyId(null);
    setUploadedPhotos(
      Object.values(PHOTO_TYPES).reduce((acc, type) => ({ ...acc, [type]: false }), {})
    );
    setTempPhotos({});
    setDrawingFile(null);
    setHasSkippedDrawing(false);
    setValidationErrors({});
    setError('');
    setIsSurveySaved(false);

    return resetData;
  };

  const handleSave = async () => {
    try {
      console.log('Starting save process...');
      console.log('Current form data:', formData);
      
      if (!validateForm()) {
        console.log('Validation errors:', validationErrors);
        setError('Please fill in all required fields marked with *');
        return false;
      }

      // Set saving state
      setIsSaving(true);

      // Format leaf gap data as strings for API compatibility
      const formattedLeafGap = {
        hingeSide: formData.leafGap.hingeSide.start && formData.leafGap.hingeSide.end 
          ? `${formData.leafGap.hingeSide.start}-${formData.leafGap.hingeSide.end}`
          : '',
        topGap: formData.leafGap.topGap.start && formData.leafGap.topGap.end 
          ? `${formData.leafGap.topGap.start}-${formData.leafGap.topGap.end}`
          : '',
        leadingEdge: formData.leafGap.leadingEdge.start && formData.leafGap.leadingEdge.end 
          ? `${formData.leafGap.leadingEdge.start}-${formData.leafGap.leadingEdge.end}`
          : ''
      };

      // Convert the entire leafGap object to a string representation
      const leafGapString = JSON.stringify(formattedLeafGap);

      // Create survey data object with proper field formatting
      const surveyData = {
        doorNumber: String(formData.doorPinNo),
        floor: formData.floor || '',
        room: formData.room || '',
        locationOfDoorSet: formData.locationOfDoorSet.trim(),
        doorType: formData.doorConfiguration.type || '',
        doorConfiguration: getDoorTypeDisplay(formData.doorConfiguration),
        doorMaterial: getDoorMaterialDisplay(formData.doorMaterial),
        rating: formData.rating || '',
        thirdPartyCertification: {
          type: formData.thirdPartyCertification?.type || '',
          customText: formData.thirdPartyCertification?.customText || '',
          photo: null, // Photos are handled separately
          photoUrl: null
        },
        surveyed: formData.surveyed || '',
        surveyedReason: formData.surveyedReason || '',
        surveyedCustomReason: formData.surveyedCustomReason || '',
        leafGap: leafGapString,
        thresholdGap: formData.thresholdGap || '',
        combinedStripsCondition: formData.combinedStripsCondition || '',
        selfCloserFunctional: formData.selfCloserFunctional || '',
        hingesCondition: formData.hingesCondition || '',
        glazingSufficient: formData.glazingSufficient || '',
        fanLightsSufficient: formData.fanLightsSufficient || '',
        upgradeReplacement: formData.upgradeReplacement || '',
        overallCondition: formData.overallCondition || '',
        notes: formData.conditionDetails?.notes || '',
        isFlagged: Boolean(formData.isFlagged)
      };

      console.log('Sending survey data:', surveyData);

      let response;
      try {
        // Try direct Axios call instead of using the API functions
        if (isEditing && surveyId) {
          response = await axios.put(`${API_BASE_URL}/api/surveys/${surveyId}`, surveyData);
          console.log('Update response:', response);
        } else {
          response = await axios.post(`${API_BASE_URL}/api/surveys`, surveyData);
          console.log('Create response:', response);
        }

        if (response.data) {
          const savedSurveyId = response.data._id || response.data.id;
          setSurveyId(savedSurveyId);

          // Upload any temporary photos if they exist
          if (Object.keys(tempPhotos).length > 0) {
            await handlePhotoUploads(savedSurveyId);
          }

          // Get all surveys
          const surveysResponse = await axios.get(`${API_BASE_URL}/api/surveys`);
          const updatedSurveys = surveysResponse.data;
          
          // Update states
          setAllSurveys(updatedSurveys);
          
          // Update surveyedDoorsList with flag status
          const updatedDoorsList = updatedSurveys.map(survey => ({
            doorNumber: survey.doorNumber,
            isFlagged: Boolean(survey.isFlagged)
          }));
          setSurveyedDoorsList(updatedDoorsList);
          
          setIsSurveySaved(true);
          setError(isEditing ? 'Survey updated successfully!' : 'Survey saved successfully!');

          setIsSaving(false);
          return true;
        } else {
          throw new Error('Failed to save survey. No response data received.');
        }
      } catch (error) {
        console.error('Error saving survey:', error);
        console.error('Error response:', error.response?.data);
        setError(error.response?.data?.message || error.message || 'Failed to save survey. Please try again.');
        setIsSaving(false);
        return false;
      }
    } catch (error) {
      console.error('Error in handleSave:', error);
      setError(error.message || 'Failed to save survey. Please try again.');
      setIsSaving(false);
      return false;
    }
  };

  const handleCancel = () => {
    navigate('/');
  };

  const renderOption = (value, isSelected, onClick, key, rangeInfo = null) => {
    let className = 'option-button';
    let dataAttributes = {};
    
    if (rangeInfo) {
      const { start, end, currentValue } = rangeInfo;
      const numValue = parseFloat(currentValue);
      const numStart = parseFloat(start);
      const numEnd = parseFloat(end);

      if (currentValue === start) {
        className += ' selected';
        dataAttributes['data-range-start'] = 'true';
      } else if (currentValue === end) {
        className += ' selected';
      } else if (start && end && numValue > numStart && numValue < numEnd) {
        className += ' in-range';
      }
    } else if (isSelected) {
      className += ' selected';
    }

    return (
    <button
      key={key}
      type="button"
        className={className}
      onClick={onClick}
        {...dataAttributes}
    >
      {value}
    </button>
  );
  };

  const getDoorTypeDisplay = (config = null) => {
    const configuration = config || formData.doorConfiguration;
    let display = configuration.type || '';
    if (configuration.hasFanLight) display += ' + With Fan Light';
    if (configuration.hasSidePanels) display += ' + With Side Panel(s)';
    if (configuration.hasVPPanel) display += ' + With VP Panel';
    return display;
  };

  // Helper function to get door material display
  const getDoorMaterialDisplay = (material) => {
    if (!material) return '';
    return material.type === 'custom' 
      ? `${material.type} - ${material.customType}` 
      : material.type;
  };

  // Function to save multiple door surveys into a single Excel workbook
  const saveSurveysToWorkbook = async (surveys) => {
    try {
      const workbook = new ExcelJS.Workbook();
      const worksheet = workbook.addWorksheet('Fire Door Surveys');

      // Add columns
      worksheet.columns = [
        { header: 'Door/Pin No.', key: 'doorPinNo', width: 15 },
        { header: 'Floor', key: 'floor', width: 15 },
        { header: 'Room', key: 'room', width: 15 },
        { header: 'Location', key: 'locationOfDoorSet', width: 20 },
        { header: 'Door Type', key: 'doorType', width: 15 },
        { header: 'Door Material', key: 'doorMaterial', width: 20 },
        { header: 'Fire Rating', key: 'rating', width: 15 },
        { header: 'Third Party Certification', key: 'certification', width: 25 },
        { header: 'Surveyed', key: 'surveyed', width: 10 },
        { header: 'Flagged for Review', key: 'isFlagged', width: 15 }
      ];

      // Style the header row
      worksheet.getRow(1).font = { bold: true };
      worksheet.getRow(1).fill = {
        type: 'pattern',
        pattern: 'solid',
        fgColor: { argb: 'FFE0E0E0' }
      };

      // Add data and style flagged rows
      surveys.forEach((survey) => {
        const row = worksheet.addRow({
          doorPinNo: survey.doorPinNo,
          floor: survey.floor,
          room: survey.room,
          locationOfDoorSet: survey.locationOfDoorSet,
          doorType: survey.doorType,
          doorMaterial: getDoorMaterialDisplay(survey.doorMaterial),
          rating: survey.rating,
          certification: survey.thirdPartyCertification?.type || 'N/A',
          surveyed: survey.surveyed,
          isFlagged: survey.isFlagged ? 'Yes' : 'No'
        });

        if (survey.isFlagged) {
          row.eachCell(cell => {
            cell.fill = {
              type: 'pattern',
              pattern: 'solid',
              fgColor: { argb: 'FFFFE0E0' }  // Light red background
            };
          });
        }
      });

      // Auto-fit columns
      worksheet.columns.forEach(column => {
        column.width = Math.max(column.width || 10, 15);
      });

      // Generate Excel file
      const buffer = await workbook.xlsx.writeBuffer();
      const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
      const url = window.URL.createObjectURL(blob);
      
      // Create download link and trigger download
      const link = document.createElement('a');
      link.href = url;
      link.download = 'fire_door_surveys.xlsx';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      window.URL.revokeObjectURL(url);

      return { success: true };
    } catch (error) {
      console.error('Error generating Excel file:', error);
      return { success: false, error: error.message };
    }
  };

  const handleDoorConfigChange = (field, value) => {
    setFormData(prev => {
      let newState = {
        ...prev,
        doorConfiguration: {
          ...prev.doorConfiguration,
          [field]: value
        }
      };
      
      // If type field is changed, update doorType as well
      if (field === 'type') {
        newState.doorType = value;
      }
      
      return newState;
    });
    setError('');
  };

  const handleDoorMaterialChange = (materialType) => {
    setFormData(prev => ({
      ...prev,
      doorMaterial: {
        ...prev.doorMaterial,
        type: materialType,
        customType: materialType === 'custom' ? prev.doorMaterial.customType : ''
      }
    }));
    setError('');
  };

  const handleCustomMaterialChange = (value) => {
    setFormData(prev => ({
      ...prev,
      doorMaterial: {
        ...prev.doorMaterial,
        customType: value
      }
    }));
    setError('');
  };

  const renderFormGroup = (label, field, children, required = false) => (
    <div className={`form-group ${validationErrors[field] ? 'has-error' : ''}`}>
      <label>{label}{required && ' *'}</label>
      <div className="form-input" id={field} name={field}>
        {children}
        {validationErrors[field] && (
          <span className="validation-error">{validationErrors[field]}</span>
        )}
      </div>
    </div>
  );

  const handleDefectPhotoUpload = (defectType, event) => {
    const file = event.target.files[0];
    if (file) {
      setFormData(prev => ({
        ...prev,
        defectPhotos: {
          ...prev.defectPhotos,
          [defectType]: {
            file,
            url: URL.createObjectURL(file)
          }
        }
      }));
    }
  };

  const renderDefectPhotoUpload = (defectType) => (
    <div className="defect-photo-upload">
      <input
        type="file"
        id={`${defectType}-photo`}
        accept="image/*"
        onChange={(e) => handleDefectPhotoUpload(defectType, e)}
        style={{ display: 'none' }}
        capture="environment"
      />
      <label htmlFor={`${defectType}-photo`} className="defect-photo-button">
        <span className="camera-icon">üì∏</span>
      </label>
      {formData.defectPhotos[defectType]?.url && (
        <div className="defect-photo-preview">
          <img 
            src={formData.defectPhotos[defectType].url} 
            alt={`${defectType} defect`} 
          />
          <button
            type="button"
            className="remove-defect-photo"
            onClick={() => {
              setFormData(prev => ({
                ...prev,
                defectPhotos: {
                  ...prev.defectPhotos,
                  [defectType]: null
                }
              }));
            }}
          >
            ‚úï
          </button>
        </div>
      )}
    </div>
  );

  const handleViewExcel = async () => {
    try {
      const response = await fetch(`${API_BASE_URL}/api/surveys`);
      if (!response.ok) {
        throw new Error('Failed to fetch surveys');
      }
      const surveys = await response.json();
      
      const result = await saveSurveysToWorkbook(surveys);
      if (!result.success) {
        setError('Failed to generate Excel file: ' + result.error);
      }
    } catch (error) {
      console.error('Error viewing Excel:', error);
      setError('Failed to generate Excel file: ' + error.message);
    }
  };

  const handleRemoveNotification = (index) => {
    setNotifications(prev => {
      const updated = prev.filter((_, i) => i !== index);
      localStorage.setItem('doorNotifications', JSON.stringify(updated));
      return updated;
    });
  };

  const handleClearSurveys = async () => {
    // Show confirmation dialog
    if (!window.confirm('WARNING: This will permanently delete all surveys. This action cannot be undone. Are you sure you want to proceed?')) {
      return;
    }

    try {
      const response = await axios.delete(`${API_BASE_URL}/api/surveys/clear`);
      
      if (response.data.success) {
        // Clear local storage and state
        localStorage.removeItem('doorNotifications');
        setNotifications([]);
        setAllSurveys([]);
        setSurveyedDoorsList([]);
        setCurrentDoor(1);
        setFormData(prevData => ({
          ...resetForm(),
          doorPinNo: 1
        }));
        setError('All surveys cleared successfully');
      } else {
        setError(`Failed to clear surveys: ${response.data.message}`);
      }
    } catch (error) {
      console.error('Error clearing surveys:', error);
      setError('Failed to clear surveys. Please try again.');
    }
  };

  const handleViewSurveys = () => {
    try {
      const sortedSurveys = [...allSurveys].sort((a, b) => 
        parseInt(a.doorNumber) - parseInt(b.doorNumber)
      );

      const newWindow = window.open('');
      newWindow.document.write(`
        <html>
          <head>
            <title>Past Fire Door Inspections</title>
            <style>
              body { 
                font-family: Arial, sans-serif; 
                padding: 20px; 
                margin: 0;
                background-color: #f5f5f5;
              }
              .container {
                max-width: 1200px;
                margin: 0 auto;
                background-color: white;
                padding: 20px;
                border-radius: 8px;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
              }
              .header {
                margin-bottom: 20px;
                padding-bottom: 20px;
                border-bottom: 2px solid #eee;
                display: flex;
                align-items: center;
                gap: 1rem;
              }
              .back-button {
                padding: 8px 16px;
                background: #34495e;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-weight: 500;
                display: flex;
                align-items: center;
                gap: 0.5rem;
                font-size: 14px;
              }
              .back-button:hover {
                background: #2c3e50;
              }
              h2 {
                margin: 0;
              }
              .read-only-notice {
                background-color: #e8f5e9;
                color: #2e7d32;
                padding: 10px;
                border-radius: 4px;
                margin-bottom: 20px;
                font-weight: 500;
              }
              table { 
                border-collapse: collapse; 
                width: 100%;
                margin-top: 20px;
              }
              th, td { 
                border: 1px solid #ddd; 
                padding: 12px 8px;
                text-align: left;
              }
              th { 
                background-color: #f8f9fa;
                font-weight: 600;
              }
              tr:nth-child(even) {
                background-color: #f8f9fa;
              }
              tr:hover {
                background-color: #f2f2f2;
              }
              .summary {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                gap: 20px;
                margin: 20px 0;
                background-color: #f8f9fa;
                padding: 15px;
                border-radius: 4px;
              }
              .summary-item {
                text-align: center;
              }
              .summary-value {
                font-size: 24px;
                font-weight: bold;
                color: #2196F3;
              }
              .summary-label {
                color: #666;
                margin-top: 5px;
              }
            </style>
          </head>
          <body>
            <div class="container">
              <div class="header">
                <button class="back-button" onclick="window.close()">‚Üê Back</button>
                <h2>Fire Door Inspection History</h2>
              </div>
              <div class="read-only-notice">
                ‚ìò This is a read-only view of past inspections. To make changes, please use the Edit function in the main form.
            </div>
              
              <div class="summary">
                <div class="summary-item">
                  <div class="summary-value">${sortedSurveys.length}</div>
                  <div class="summary-label">Total Doors Surveyed</div>
                </div>
                <div class="summary-item">
                  <div class="summary-value">${sortedSurveys.filter(s => s.surveyed === 'Y').length}</div>
                  <div class="summary-label">Passed Inspection</div>
                </div>
                <div class="summary-item">
                  <div class="summary-value">${sortedSurveys.filter(s => s.surveyed === 'N').length}</div>
                  <div class="summary-label">Failed Inspection</div>
                </div>
                <div class="summary-item">
                  <div class="summary-value">${((sortedSurveys.filter(s => s.surveyed === 'Y').length / sortedSurveys.length) * 100).toFixed(1)}%</div>
                  <div class="summary-label">Pass Rate</div>
                </div>
              </div>

              <table>
                <thead>
                  <tr>
                    <th>Door Number</th>
                    <th>Location</th>
                    <th>Floor</th>
                    <th>Room</th>
                    <th>Door Type</th>
                    <th>Rating</th>
                    <th>Status</th>
                    <th>Condition</th>
                    <th>Action Required</th>
                  </tr>
                </thead>
                <tbody>
                  ${sortedSurveys.map(survey => `
                    <tr>
                      <td>${survey.doorNumber}</td>
                      <td>${survey.locationOfDoorSet || '-'}</td>
                      <td>${survey.floor || '-'}</td>
                      <td>${survey.room || '-'}</td>
                      <td>${survey.doorType || '-'}</td>
                      <td>${survey.rating || '-'}</td>
                      <td>${survey.surveyed === 'Y' ? 'Pass' : 'Fail'}</td>
                      <td>${survey.overallCondition || '-'}</td>
                      <td>${survey.upgradeReplacement || '-'}</td>
                    </tr>
                  `).join('')}
                </tbody>
              </table>
            </div>
          </body>
        </html>
      `);
    } catch (error) {
      console.error('Error displaying inspection history:', error);
      setError('Failed to display inspection history. Please try again.');
    }
  };

  const handleEditSurvey = async (doorNumber) => {
    await loadSurveyData(doorNumber);
  };

  const handleContinueSurvey = useCallback(async () => {
    // Store state values at the beginning to ensure consistency
    const wasCurrentDoorFlagged = formData.isFlagged;
    const currentDoorNumber = currentDoor.toString();
    const wasSurveySaved = isSurveySaved;
    
    // Handle save prompt when needed
    if (!wasSurveySaved) {
      const savePromptMessage = wasCurrentDoorFlagged 
        ? 'This door is flagged for review. Do you want to save before continuing?' 
        : 'Do you want to save the current survey before continuing?';
      
      const shouldSave = window.confirm(savePromptMessage);
      
      if (shouldSave) {
        try {
          const saveResult = await handleSave();
          if (!saveResult) return; // Stop if save failed
        } catch (error) {
          setError('Failed to save survey: ' + error.message);
          return; // Don't continue if save fails
        }
      }
    }

    // Calculate next door number once
    const nextDoorNumber = currentDoor + 1;

    // Update surveyedDoorsList to preserve the flag status if needed
    if (wasCurrentDoorFlagged) {
      setSurveyedDoorsList(prevList => {
        const updatedList = [...prevList];
        const existingIndex = updatedList.findIndex(door => door.doorNumber === currentDoorNumber);
        
        if (existingIndex !== -1) {
          updatedList[existingIndex] = {
            ...updatedList[existingIndex],
            isFlagged: true
          };
        } else {
          updatedList.push({
            doorNumber: currentDoorNumber,
            isFlagged: true
          });
        }
        
        return updatedList;
      });
    }

    // Reset form and update state efficiently
    const resetData = resetForm();
    
    // Batch state updates
    setFormData({
      ...resetData,
      doorPinNo: nextDoorNumber,
      isFlagged: false
    });
    setIsSurveySaved(false);
    setCurrentDoor(nextDoorNumber);
  }, [currentDoor, formData.isFlagged, isSurveySaved, handleSave, resetForm]);

  const handleBackToMenu = () => {
    navigate('/');
  };

  const handleThirdPartyCertificationChange = (type) => {
    setFormData(prev => ({
      ...prev,
      thirdPartyCertification: {
        ...prev.thirdPartyCertification,
        type,
        customText: type === 'custom' ? prev.thirdPartyCertification.customText : ''
      }
    }));
    setError('');
  };

  const handleCustomCertificationChange = (value) => {
    setFormData(prev => ({
      ...prev,
      thirdPartyCertification: {
        ...prev.thirdPartyCertification,
        customText: value
      }
    }));
    setError('');
  };

  const handleCertificationPhotoUpload = (event) => {
    const file = event.target.files[0];
    if (file) {
      setFormData(prev => ({
        ...prev,
        thirdPartyCertification: {
          ...prev.thirdPartyCertification,
          photo: file,
          photoUrl: URL.createObjectURL(file)
        }
      }));
    }
  };

  const handleToggleFlag = useCallback(() => {
    // Toggle flag status using a function state update to ensure latest state
    setFormData(prev => {
      const newFlagStatus = !prev.isFlagged;
      return { ...prev, isFlagged: newFlagStatus };
    });
    
    // Update surveyedDoorsList to reflect the flag change efficiently
    setSurveyedDoorsList(prevList => {
      // Create a copy of the current list
      const newList = [...prevList];
      const currentDoorStr = currentDoor.toString();
      const existingIndex = newList.findIndex(door => door.doorNumber === currentDoorStr);
      
      // Function-style state update ensures we have the latest formData state
      const newFlagStatus = !formData.isFlagged;
      
      if (existingIndex !== -1) {
        // Update existing door's flag status
        newList[existingIndex] = {
          ...newList[existingIndex],
          isFlagged: newFlagStatus
        };
      } else if (newFlagStatus) {
        // Add new entry only if flagging (not unflagging a non-existent entry)
        newList.push({
          doorNumber: currentDoorStr,
          isFlagged: true
        });
      }
      
      return newList;
    });
  }, [currentDoor, formData.isFlagged]);

  const handleFinalAssessmentChange = (value) => {
    setFormData(prevData => ({
      ...prevData,
      finalAssessment: value,
      upgradeReplacement: value, // Ensure upgradeReplacement is set
      // Reset measurements if not replacing door or leaf
      height: value === 'Replace Doorset' || value === 'Replace leaf' ? prevData.height : '',
      width: value === 'Replace Doorset' || value === 'Replace leaf' ? prevData.width : '',
      depth: value === 'Replace Doorset' || value === 'Replace leaf' ? prevData.depth : ''
    }));
    setShowMeasurements(value === 'Replace Doorset' || value === 'Replace leaf');
  };

  const handleRoomTypeSelect = (roomType) => {
    handleInputChange('room', roomType);
  };

  const handleQuickSelectThickness = (value) => {
    handleInputChange('leafThickness', value);
  };

  const handleRemovePhoto = (photoType) => {
    setFormData(prev => ({
      ...prev,
      measurements: {
        ...prev.measurements,
        [`${photoType}Photo`]: null,
        [`${photoType}PhotoUrl`]: null
      }
    }));
  };

  const handleGapComplete = (type) => {
    // Auto-scroll to next section
    const nextGapMap = {
      'hingeSide': 'topGap',
      'topGap': 'leadingEdge'
    };
    
    const nextGap = nextGapMap[type];
    if (nextGap) {
      setExpandedGap(nextGap);
      // Add small delay to allow state to update
      setTimeout(() => {
        document.querySelector(`.gap-accordion[data-type="${nextGap}"]`)?.scrollIntoView({
          behavior: 'smooth',
          block: 'nearest'
        });
      }, 100);
    }
  };

  const isGapCompliant = (gapData) => {
    if (!gapData.start || !gapData.end) return false;
    const start = parseFloat(gapData.start);
    const end = parseFloat(gapData.end);
    return start >= 2 && end <= 4;
  };

  // Add a new helper function to check if glazing assessment should be shown
  const shouldShowGlazingAssessment = () => {
    return formData.doorConfiguration.hasVPPanel || 
           formData.doorConfiguration.hasFanLight || 
           formData.doorConfiguration.hasSidePanels;
  };

  const handleBackToPrepositions = () => {
    setCurrentWordSet('initial');
    setIsAddingWord(false);
  };

  // Add common location phrases
  const commonLocationPhrases = [
    'Next to Next to',
    'Next to Opposite',
    'Next to Next to Opposite',
    'Opposite Next to',
    'Between Next to',
    'Inside Next to',
    'Outside Next to',
    'Leading into Next to'
  ];

  // Add function to handle phrase selection
  const handlePhraseSelect = (phrase) => {
    handleInputChange('locationOfDoorSet', phrase);
  };

  const handlePhotoUploads = useCallback(async (surveyId) => {
    try {
      const uploadPromises = Object.entries(tempPhotos).map(([photoType, file]) => 
        uploadSurveyPhoto(surveyId, photoType, file)
      );
      await Promise.all(uploadPromises);
      return true;
    } catch (error) {
      console.error('Error uploading photos:', error);
      throw error;
    }
  }, [tempPhotos]);

  return (
    <div className="fire-door-survey-form">
      <div className="form-header">
        <div className="header-content">
          <button className="back-button" onClick={handleBackToMenu}>
            ‚Üê Back to Menu
          </button>
          <h2>Fire Door Survey Form</h2>
        </div>
      </div>
      
      {error && (
        <div className="error-message">
          <span><span className="error-message-icon">‚ö†Ô∏è</span> {error}</span>
          <button onClick={() => setError('')} className="close-error">‚úï</button>
        </div>
      )}
      
      <div className="clear-surveys-container">
        <button
          className="clear-button"
          onClick={handleClearSurveys}
          disabled={allSurveys.length === 0}
        >
          Clear All Surveys ({allSurveys.length})
        </button>
      </div>

      <SurveyTracker 
        totalSurveys={Math.max(...surveyedDoorsList.map(door => Number(door.doorNumber) || 0), currentDoor)}
        currentDoor={currentDoor}
        onDoorChange={handleDoorChange}
        surveyedDoorsList={surveyedDoorsList}
        onViewSurveys={handleViewSurveys}
        onEditSurvey={handleEditSurvey}
        onContinueSurvey={handleContinueSurvey}
        isFlagged={formData.isFlagged}
      />

      <div className="drawing-section">
        <h2>Drawing Upload</h2>
        <div className="drawing-upload-container">
          <button
            className="upload-button"
            onClick={() => document.getElementById('drawing-upload').click()}
          >
            Import Drawing
          </button>
                <input
                  type="file"
                  id="drawing-upload"
            accept="image/*"
                  onChange={handleDrawingUpload}
                  style={{ display: 'none' }}
                />
              <button
            className="skip-button"
                onClick={handleSkipDrawing}
              >
                Skip Drawing
              </button>
            </div>
        {formData.drawing && (
            <div className="drawing-status">
                <div className="drawing-preview">
              <span>Drawing uploaded: {formData.drawing.name}</span>
                  <button
                    className="remove-drawing-button"
                onClick={() => setFormData(prev => ({ ...prev, drawing: null }))}
                  >
                    Remove
                  </button>
                </div>
          </div>
        )}
        {formData.drawingSkipped && (
          <div className="drawing-status">
                <div className="drawing-skipped">
                  <span>Drawing upload skipped</span>
                  <button
                    className="change-drawing-button"
                onClick={() => setFormData(prev => ({ ...prev, drawingSkipped: false }))}
                  >
                    Change
                  </button>
                </div>
            </div>
          )}
        </div>

      <section className="form-section">
        <div className="number-input-group">
          <label>Door/Pin No.</label>
          <input
            type="number"
            value={formData.doorPinNo}
            onChange={(e) => handleInputChange('doorPinNo', e.target.value)}
            min="0"
            className="number-input"
          />
        </div>
      </section>

      <section className="form-section">
        <h3>Basic Information</h3>
        
        {/* Floor */}
        <div className="form-group">
          <label>Floor</label>
          <div className="floor-selection">
          <select
              className="select-input"
            value={formData.floor}
            onChange={(e) => handleInputChange('floor', e.target.value)}
          >
            <option value="">Select Floor</option>
              <option value="Basement">Basement</option>
              <option value="Ground Floor">Ground Floor</option>
              {[...Array(20)].map((_, index) => (
                <option key={index + 1} value={`${index + 1}`}>
                  {`${index + 1}${index === 0 ? 'st' : index === 1 ? 'nd' : index === 2 ? 'rd' : 'th'} Floor`}
                </option>
              ))}
              <option value="custom">Other (specify)</option>
          </select>
            {formData.floor === 'custom' && (
              <input
                type="text"
                className="text-input"
                placeholder="Enter custom floor"
                value={formData.customFloor || ''}
                onChange={(e) => {
                  setFormData(prev => ({
                    ...prev,
                    customFloor: e.target.value,
                    floor: 'custom'
                  }));
                }}
              />
            )}
          </div>
        </div>

        {/* Room */}
        <div className="form-group">
          <label>Room *</label>
          <div>
            <RoomTypeSelector
            value={formData.room}
              onSelect={handleRoomTypeSelect}
              initialValue={formData.room}
            />
            {validationErrors.room && <span className="validation-error">{validationErrors.room}</span>}
          </div>
        </div>

        {/* Location of Door Set */}
        <div className="form-group">
          <label>Location of Door Set *</label>
          <div>
            <div className="location-prepositions">
              {currentWordSet === 'places' && (
                <button
                  type="button"
                  className="back-to-prepositions"
                  onClick={handleBackToPrepositions}
                >
                  ‚Üê Back
                </button>
              )}
              <div className="preposition-row">
                {[...WORD_SETS[currentWordSet], ...customWords[currentWordSet]].map((word, index) => (
                  <button
                    key={index}
                    type="button"
                    className={`preposition-button ${formData.locationOfDoorSet.includes(word) ? 'selected' : ''}`}
                    onClick={() => handleLocationOption(word)}
                  >
                    {word}
                  </button>
                ))}
                {isAddingWord ? (
                  <div className="add-word-container">
                    <input
                      type="text"
                      className="add-word-input"
                      value={newWord}
                      onChange={(e) => setNewWord(e.target.value)}
                      onKeyPress={(e) => {
                        if (e.key === 'Enter') {
                          handleAddCustomWord();
                        }
                      }}
                      placeholder={`Add custom ${currentWordSet === 'initial' ? 'preposition' : 'place'}...`}
                      autoFocus
                    />
                    <button
                      type="button"
                      className="add-word-confirm"
                      onClick={handleAddCustomWord}
                    >
                      Add
                    </button>
                    <button
                      type="button"
                      className="add-word-cancel"
                      onClick={() => {
                        setIsAddingWord(false);
                        setNewWord('');
                      }}
                    >
                      Cancel
                    </button>
                  </div>
                ) : (
                  <button
                    type="button"
                    className="preposition-button"
                    onClick={() => handleLocationOption('+')}
                  >
                    +
                  </button>
                )}
              </div>
            </div>
            <div className="location-input">
              <input
                type="text"
                className="text-input"
                placeholder="Enter location..."
                value={formData.locationOfDoorSet}
                onChange={(e) => handleInputChange('locationOfDoorSet', e.target.value)}
                required
              />
            </div>
          </div>
          {validationErrors.locationOfDoorSet && (
            <span className="validation-error">{validationErrors.locationOfDoorSet}</span>
          )}
        </div>
      </section>

      <section className="form-section">
        <h3>Door Specifications</h3>
        <div className="form-group">
          <label>Door Set Configuration *</label>
          <div className="door-config-section">
            <div className={`options-group ${validationErrors.doorConfiguration ? 'has-error' : ''}`}>
              {['Single', 'Double', 'Leaf & half'].map(type => 
                renderOption(
                  type,
                  formData.doorConfiguration.type === type,
                  () => handleDoorConfigChange('type', type),
                  `door-type-${type}`
                )
              )}
              <button
                className={`option-button ${formData.doorConfiguration.hasVPPanel ? 'selected' : ''}`}
                onClick={(e) => handleDoorConfigChange('hasVPPanel', !formData.doorConfiguration.hasVPPanel)}
              >
                With VP Panel
              </button>
            </div>
            {validationErrors.doorConfiguration && (
              <span className="validation-error">{validationErrors.doorConfiguration}</span>
            )}
            <div className="additional-options">
              <label className="checkbox-label">
                <input
                  type="checkbox"
                  checked={formData.doorConfiguration.hasFanLight}
                  onChange={(e) => handleDoorConfigChange('hasFanLight', e.target.checked)}
                />
                With Fan Light
              </label>
              <label className="checkbox-label">
                <input
                  type="checkbox"
                  checked={formData.doorConfiguration.hasSidePanels}
                  onChange={(e) => handleDoorConfigChange('hasSidePanels', e.target.checked)}
                />
                With Side Panel(s)
              </label>
            </div>
            {formData.doorConfiguration.type && (
              <div className="door-config-display">
                Selected Configuration: {getDoorTypeDisplay()}
              </div>
            )}
          </div>
        </div>
      </section>

      <div className="form-group">
          <label>Accessed *</label>
          <div className="options-group" id="surveyed" name="surveyed">
            {['Y', 'N'].map(value => 
              renderOption(value, formData.surveyed === value, () => handleSurveyedChange(value), `surveyed-${value}`)
            )}
          </div>
          {formData.surveyed === 'N' && (
            <div className="not-accessed-reason">
              <div className="predefined-reasons">
                {[
                  'Locked - No key available',
                  'Locked - No code available',
                  'Room occupied',
                  'Room in use',
                  'No access permitted'
                ].map(reason => (
                  <button
                    key={reason}
                    type="button"
                    className={`reason-button ${formData.surveyedReason === reason ? 'selected' : ''}`}
                    onClick={() => handleSurveyedReasonChange(reason)}
                  >
                    {reason}
                  </button>
                ))}
              </div>
              <div className="custom-reason">
                <input
                  type="text"
                  className="text-input"
                  placeholder="Or enter custom reason"
                  value={formData.surveyedCustomReason}
                  onChange={(e) => handleSurveyedCustomReasonChange(e.target.value)}
                />
              </div>
            </div>
          )}
          {validationErrors.surveyed && (
            <span className="validation-error">{validationErrors.surveyed}</span>
          )}
        </div>
      </section>

      <section className="form-section">
        <h3>Measurements</h3>
        
        <div className="form-group">
          <label>Leaf thickness (mm)</label>
          <div className="measurement-section">
            <div className="measurement-input-container">
            <input
              type="number"
              value={formData.leafThickness || ''}
              onChange={(e) => handleInputChange('leafThickness', e.target.value)}
              className="number-input"
              min="0"
              step="1"
              placeholder="Enter thickness"
            />
              <div className="quick-select-buttons">
                {commonThicknessValues.map(value => (
                  <button
                    key={value}
                    className={`quick-select-button ${formData.leafThickness === value ? 'selected' : ''}`}
                    onClick={() => handleQuickSelectThickness(value)}
                  >
                    {value}mm
                  </button>
                ))}
                </div>
            </div>
            <div className="photo-upload-container">
                  <button
                    type="button"
                className="photo-upload-button"
                onClick={() => document.getElementById('leafThicknessPhoto').click()}
              >
                <span className="upload-icon">üì∑</span>
                  </button>
              <input
                type="file"
                id="leafThicknessPhoto"
                accept="image/*"
                style={{ display: 'none' }}
                onChange={(e) => handlePhotoUpload('leafThickness', e)}
              />
              {formData.measurements.leafThicknessPhoto && (
                <div className="photo-preview">
                  <img src={formData.measurements.leafThicknessPhotoUrl} alt="Leaf thickness" />
                  <button
                    className="remove-photo"
                    onClick={() => handleRemovePhoto('leafThickness')}
                  >
                    √ó
                  </button>
                </div>
              )}
              <span>Upload Photo</span>
            </div>
          </div>
        </div>

        <div className="form-group">
          <label>Leaf Gap Measurements (mm)</label>
          <div className="gap-measurements-container">
            <GapMeasurementAccordion
              type="hingeSide"
              label="Hinge Side"
              gapData={formData.leafGap.hingeSide}
              onGapChange={handleLeafGapChange}
              onPhotoUpload={handleHingeSidePhotoUpload}
              photoUrl={formData.measurements.hingeSidePhotoUrl}
              onPhotoRemove={() => handleRemovePhoto('hingeSide')}
              isExpanded={expandedGap === 'hingeSide'}
              onToggle={() => setExpandedGap(expandedGap === 'hingeSide' ? '' : 'hingeSide')}
              onRangeComplete={handleGapComplete}
              isCompliant={isGapCompliant(formData.leafGap.hingeSide)}
            />

            <GapMeasurementAccordion
              type="topGap"
              label="Top Gap"
              gapData={formData.leafGap.topGap}
              onGapChange={handleLeafGapChange}
              onPhotoUpload={handleTopGapPhotoUpload}
              photoUrl={formData.measurements.topGapPhotoUrl}
              onPhotoRemove={() => handleRemovePhoto('topGap')}
              isExpanded={expandedGap === 'topGap'}
              onToggle={() => setExpandedGap(expandedGap === 'topGap' ? '' : 'topGap')}
              onRangeComplete={handleGapComplete}
              isCompliant={isGapCompliant(formData.leafGap.topGap)}
            />

            <GapMeasurementAccordion
              type="leadingEdge"
              label="Leading Edge"
              gapData={formData.leafGap.leadingEdge}
              onGapChange={handleLeafGapChange}
              onPhotoUpload={handleLeadingEdgePhotoUpload}
              photoUrl={formData.measurements.leadingEdgePhotoUrl}
              onPhotoRemove={() => handleRemovePhoto('leadingEdge')}
              isExpanded={expandedGap === 'leadingEdge'}
              onToggle={() => setExpandedGap(expandedGap === 'leadingEdge' ? '' : 'leadingEdge')}
              onRangeComplete={handleGapComplete}
              isCompliant={isGapCompliant(formData.leafGap.leadingEdge)}
            />
          </div>
        </div>
      </section>

      <section className="form-section">
        <h3>Condition Assessment</h3>
        
        <div className="form-group">
          <label>Frame in good condition</label>
          <div className="options-group">
            {['Y', 'N'].map(value => 
              renderOption(value, formData.frameCondition === value, () => handleOptionClick('frameCondition', value), `frame-${value}`)
            )}
          </div>
          {formData.frameCondition === 'N' && (
            <div className="defect-input-section">
              <div className="defect-header">
                {renderDefectPhotoUpload('frame')}
                <select
                  value={formData.frameDefect}
                  onChange={(e) => handleInputChange('frameDefect', e.target.value)}
                  className="select-input"
                >
                  <option value="">Select Defect</option>
                  <option value="Split Frame">Split Frame</option>
                  <option value="Loose Frame">Loose Frame</option>
                  <option value="Excessive Damage / Cracking">Excessive Damage / Cracking</option>
                  <option value="Rotten Timber / Decay">Rotten Timber / Decay</option>
                  <option value="Warped / Bowed Frame">Warped / Bowed Frame</option>
                  <option value="Frame Not Securely Fixed">Frame Not Securely Fixed</option>
                  <option value="Hinges Pulling from Frame">Hinges Pulling from Frame</option>
                  <option value="Incompatible Frame Material">Incompatible Frame Material</option>
                  <option value="Frame Swollen (moisture-related)">Frame Swollen (moisture-related)</option>
                  <option value="Impact Damage">Impact Damage</option>
                  <option value="Previous Poor Repairs">Previous Poor Repairs</option>
                  <option value="Corroded Metal Frame">Corroded Metal Frame</option>
                  <option value="Frame Undercut or Trimmed Incorrectly">Frame Undercut or Trimmed Incorrectly</option>
                  <option value="custom">Other (specify)</option>
                </select>
              </div>
              {formData.frameDefect === 'custom' && (
                <input
                  type="text"
                  className="text-input"
                  placeholder="Enter custom defect"
                  value={formData.frameCustomDefect || ''}
                  onChange={(e) => handleInputChange('frameCustomDefect', e.target.value)}
                />
              )}
            </div>
          )}
        </div>

        <div className="form-group">
          <label>Handles/furniture sufficient</label>
          <div className="options-group">
            {['Y', 'N'].map(value => 
              renderOption(value, formData.handlesSufficient === value, () => handleOptionClick('handlesSufficient', value), `handles-${value}`)
            )}
          </div>
          {formData.handlesSufficient === 'N' && (
            <div className="defect-input-section">
              <div className="defect-header">
                {renderDefectPhotoUpload('handles')}
                <select
                  value={formData.handlesDefect}
                  onChange={(e) => handleInputChange('handlesDefect', e.target.value)}
                  className="select-input"
                >
                  <option value="">Select Defect</option>
                  <option value="Handle Missing">Handle Missing</option>
                  <option value="Handle Loose or Damaged">Handle Loose or Damaged</option>
                  <option value="Handle Not Operating Latch">Handle Not Operating Latch</option>
                  <option value="Incompatible Handle Type">Incompatible Handle Type</option>
                  <option value="Return-to-Door Handle Missing">Return-to-Door Handle Missing</option>
                  <option value="Poorly Aligned Furniture">Poorly Aligned Furniture</option>
                  <option value="Latch Misaligned or Sticking">Latch Misaligned or Sticking</option>
                  <option value="Excessive Wear or Corrosion">Excessive Wear or Corrosion</option>
                  <option value="Fixings Missing or Loose">Fixings Missing or Loose</option>
                  <option value="custom">Other (specify)</option>
                </select>
              </div>
              {formData.handlesDefect === 'custom' && (
                <input
                  type="text"
                  className="text-input"
                  placeholder="Enter custom defect"
                  value={formData.handlesCustomDefect || ''}
                  onChange={(e) => handleInputChange('handlesCustomDefect', e.target.value)}
                />
              )}
            </div>
          )}
        </div>

        <div className="form-group">
          <label>Signage satisfactory</label>
          <div className="options-group">
            {['Y', 'N'].map(value => 
              renderOption(value, formData.signageSatisfactory === value, () => handleOptionClick('signageSatisfactory', value), `signage-${value}`)
            )}
          </div>
          {formData.signageSatisfactory === 'N' && (
            <div className="defect-input-section">
              <div className="defect-header">
                {renderDefectPhotoUpload('signage')}
                <select
                  value={formData.signageDefect}
                  onChange={(e) => handleInputChange('signageDefect', e.target.value)}
                  className="select-input"
                >
                  <option value="">Select Defect</option>
                  <option value="Missing Fire Door Keep Shut Sign">Missing Fire Door Keep Shut Sign</option>
                  <option value="Missing Fire Door Keep Locked Sign">Missing Fire Door Keep Locked Sign</option>
                  <option value="Missing Fire Door Keep Clear Sign">Missing Fire Door Keep Clear Sign</option>
                  <option value="Incorrect Sign Type">Incorrect Sign Type</option>
                  <option value="Sign Not Clearly Visible">Sign Not Clearly Visible</option>
                  <option value="Wrong Location (e.g. wrong face of door)">Wrong Location (e.g. wrong face of door)</option>
                  <option value="Obsolete or Non-Compliant Signage">Obsolete or Non-Compliant Signage</option>
                  <option value="Not Photoluminescent (where required)">Not Photoluminescent (where required)</option>
                  <option value="Sign Installed on Glazing (non-compliant)">Sign Installed on Glazing (non-compliant)</option>
                  <option value="Sign Faded or Peeling">Sign Faded or Peeling</option>
                  <option value="Sign Obstructed by Furniture or Equipment">Sign Obstructed by Furniture or Equipment</option>
                  <option value="Inappropriate Adhesive or Fixings">Inappropriate Adhesive or Fixings</option>
                  <option value="Multiple Conflicting Signs">Multiple Conflicting Signs</option>
                  <option value="custom">Other (specify)</option>
                </select>
              </div>
              {formData.signageDefect === 'custom' && (
                <input
                  type="text"
                  className="text-input"
                  placeholder="Enter custom defect"
                  value={formData.signageCustomDefect || ''}
                  onChange={(e) => handleInputChange('signageCustomDefect', e.target.value)}
                />
              )}
            </div>
          )}
        </div>

        <div className="form-group">
          <label>Combined Strips Condition</label>
          <div className="options-group">
            {['Yes', 'No'].map(value => 
              renderOption(value, formData.combinedStripsCondition === value, () => handleOptionClick('combinedStripsCondition', value), `strips-${value}`)
            )}
          </div>
          {formData.combinedStripsCondition === 'No' && (
            <div className="defect-input-section">
              <div className="defect-header">
                {renderDefectPhotoUpload('combinedStrips')}
                <select
                  value={formData.combinedStripsDefect}
                  onChange={(e) => handleInputChange('combinedStripsDefect', e.target.value)}
                  className="select-input"
                >
                  <option value="">Select Defect</option>
                  <option value="Missing Strip(s)">Missing Strip(s)</option>
                  <option value="Damaged or Torn Strip">Damaged or Torn Strip</option>
                  <option value="Not Continuous">Not Continuous</option>
                  <option value="Incorrect Size or Type">Incorrect Size or Type</option>
                  <option value="Smoke seal Painted Over">Smoke seal Painted Over</option>
                  <option value="Not Fully Inserted or Loose">Not Fully Inserted or Loose</option>
                  <option value="Poor Adhesion (falling off)">Poor Adhesion (falling off)</option>
                  <option value="Crushed or Compressed">Crushed or Compressed</option>
                  <option value="Smoke Seal Missing (brush or fin)">Smoke Seal Missing (brush or fin)</option>
                  <option value="Strips Installed on both Leaf and Frame">Strips Installed on both Leaf and Frame</option>
                  <option value="Strip Excessively Worn">Strip Excessively Worn</option>
                  <option value="Two Types of Strip Mixed">Two Types of Strip Mixed</option>
                  <option value="custom">Other (specify)</option>
                </select>
              </div>
              {formData.combinedStripsDefect === 'custom' && (
                <input
                  type="text"
                  className="text-input"
                  placeholder="Enter custom defect"
                  value={formData.combinedStripsCustomDefect || ''}
                  onChange={(e) => handleInputChange('combinedStripsCustomDefect', e.target.value)}
                />
              )}
            </div>
          )}
        </div>

        <div className="form-group">
          <label>Self Closer Device Functional</label>
          <div className="options-group">
            {['Yes', 'No', 'N/A'].map(value => 
              renderOption(value, formData.selfCloserFunctional === value, () => handleOptionClick('selfCloserFunctional', value), `closer-${value}`)
            )}
          </div>
          {formData.selfCloserFunctional === 'No' && (
            <div className="defect-input-section">
              <div className="defect-header">
                {renderDefectPhotoUpload('selfCloser')}
                <select
                  value={formData.selfCloserDefect}
                  onChange={(e) => handleInputChange('selfCloserDefect', e.target.value)}
                  className="select-input"
                >
                  <option value="">Select Defect</option>
                  <option value="Closer Missing">Closer Missing</option>
                  <option value="Closer Leaking Oil">Closer Leaking Oil</option>
                  <option value="Closer Too Weak (Does Not Close Fully)">Closer Too Weak (Does Not Close Fully)</option>
                  <option value="Closer Too Strong (Slams Door)">Closer Too Strong (Slams Door)</option>
                  <option value="Closer Not Closing Into Latch">Closer Not Closing Into Latch</option>
                  <option value="Obstruction Preventing Closure">Obstruction Preventing Closure</option>
                  <option value="Closer Installed Incorrectly">Closer Installed Incorrectly</option>
                  <option value="Incorrect Closer Type for Door Size">Incorrect Closer Type for Door Size</option>
                  <option value="Damaged or Bent Arm">Damaged or Bent Arm</option>
                  <option value="No Delayed Action Where Required">No Delayed Action Where Required</option>
                  <option value="Hold-Open Function Not Releasing">Hold-Open Function Not Releasing</option>
                  <option value="Fire-Rated Closer Not Installed">Fire-Rated Closer Not Installed</option>
                  <option value="Overhead Closer Cover Missing">Overhead Closer Cover Missing</option>
                  <option value="custom">Other (specify)</option>
                </select>
              </div>
              {formData.selfCloserDefect === 'custom' && (
                <input
                  type="text"
                  className="text-input"
                  placeholder="Enter custom defect"
                  value={formData.selfCloserCustomDefect || ''}
                  onChange={(e) => handleInputChange('selfCloserCustomDefect', e.target.value)}
                />
              )}
            </div>
          )}
        </div>

        <div className="form-group">
          <label>Hinges Compliant</label>
          <div className="options-group">
            {['Yes', 'No'].map(value => 
              renderOption(value, formData.hingesCondition === value, () => handleOptionClick('hingesCondition', value), `hinges-${value}`)
            )}
          </div>
          {formData.hingesCondition === 'No' && (
            <div className="defect-input-section">
              <div className="defect-header">
                {renderDefectPhotoUpload('hinges')}
                <select
                  value={formData.hingesDefect}
                  onChange={(e) => handleInputChange('hingesDefect', e.target.value)}
                  className="select-input"
                >
                  <option value="">Select Defect</option>
                  <option value="Hinge Missing">Hinge Missing</option>
                  <option value="Loose Hinges">Loose Hinges</option>
                  <option value="Incorrect Number of Hinges (Less Than 3)">Incorrect Number of Hinges (Less Than 3)</option>
                  <option value="Hinges Not Fire-Rated">Hinges Not Fire-Rated</option>
                  <option value="Unsuitable Hinge Type">Unsuitable Hinge Type</option>
                  <option value="Damaged or Bent Hinges">Damaged or Bent Hinges</option>
                  <option value="Hinge Screws Missing or Loose">Hinge Screws Missing or Loose</option>
                  <option value="Screws Not Fire-Rated / Incompatible">Screws Not Fire-Rated / Incompatible</option>
                  <option value="Hinges Painted Over">Hinges Painted Over</option>
                  <option value="Misaligned Hinges">Misaligned Hinges</option>
                  <option value="Uneven Door Support / Sagging">Uneven Door Support / Sagging</option>
                  <option value="Signs of Excessive Wear">Signs of Excessive Wear</option>
                  <option value="Wrong Size / Gauge Hinges for Door Weight">Wrong Size / Gauge Hinges for Door Weight</option>
                  <option value="Non-Matching Hinge Set">Non-Matching Hinge Set</option>
                  <option value="custom">Other (specify)</option>
                </select>
              </div>
              {formData.hingesDefect === 'custom' && (
                <input
                  type="text"
                  className="text-input"
                  placeholder="Enter custom defect"
                  value={formData.hingesCustomDefect || ''}
                  onChange={(e) => handleInputChange('hingesCustomDefect', e.target.value)}
                />
              )}
            </div>
          )}
        </div>
      </section>

      {shouldShowGlazingAssessment() && (
        <section className="form-section">
          <h3>Glazing Assessment</h3>
          <div className="form-group">
            <label>Glazing Sufficient</label>
            <div className="options-group">
              {['Yes', 'No', 'N/A'].map(value => 
                renderOption(value, formData.glazingSufficient === value, () => handleOptionClick('glazingSufficient', value), `glazing-${value}`)
              )}
            </div>
            {formData.glazingSufficient === 'No' && (
              <div className="defect-input-section">
                <div className="defect-header">
                  {renderDefectPhotoUpload('glazing')}
                  <select
                    value={formData.glazingDefect}
                    onChange={(e) => handleInputChange('glazingDefect', e.target.value)}
                    className="select-input"
                  >
                    <option value="">Select Defect</option>
                    <option value="custom">Other (specify)</option>
                  </select>
                </div>
                {formData.glazingDefect === 'custom' && (
                  <input
                    type="text"
                    className="text-input"
                    placeholder="Enter custom defect"
                    value={formData.glazingCustomDefect || ''}
                    onChange={(e) => handleInputChange('glazingCustomDefect', e.target.value)}
                  />
                )}
              </div>
            )}
          </div>
        </section>
      )}

      <section className="form-section">
        <div className="assessment-header">
        <h3>Final Assessment</h3>
          <button 
            type="button"
            className={`flag-button-with-text ${formData.isFlagged ? 'flagged' : ''}`}
            onClick={handleToggleFlag}
            title={formData.isFlagged ? 'Remove flag' : 'Flag this door for review'}
          >
            <span className="flag-icon">üö©</span>
            <span className="flag-text">
              {formData.isFlagged ? 'Flagged for review' : 'Flag for review'}
            </span>
          </button>
          </div>
        <div className="form-group">
          <label className="required">Upgrade/Replacement/No Access *</label>
          <div className="button-group">
            <button
              type="button"
              className={`option-button ${formData.upgradeReplacement === 'Upgrade' ? 'selected' : ''}`}
              onClick={() => handleFinalAssessmentChange('Upgrade')}
            >
              Upgrade
            </button>
            <button
              type="button"
              className={`option-button ${formData.upgradeReplacement === 'Replace Doorset' ? 'selected' : ''}`}
              onClick={() => handleFinalAssessmentChange('Replace Doorset')}
            >
              Replace Doorset
            </button>
            <button
              type="button"
              className={`option-button ${formData.upgradeReplacement === 'Replace leaf' ? 'selected' : ''}`}
              onClick={() => handleFinalAssessmentChange('Replace leaf')}
            >
              Replace leaf
            </button>
              </div>
        </div>

        {showMeasurements && (
          <div className="form-section measurements-section">
            <label>Rough overall doorset measurements (mm)</label>
            <div className="measurements-grid">
              <div className="measurement-input">
                <label>Height</label>
                <input
                  type="number"
                  value={formData.height || ''}
                  onChange={(e) => handleInputChange('height', e.target.value)}
                  placeholder="Height in mm"
                  min="0"
                />
            </div>
              <div className="measurement-input">
                <label>Width</label>
                <input
                  type="number"
                  value={formData.width || ''}
                  onChange={(e) => handleInputChange('width', e.target.value)}
                  placeholder="Width in mm"
                  min="0"
                />
        </div>
              <div className="measurement-input">
                <label>Depth</label>
                <input
                  type="number"
                  value={formData.depth || ''}
                  onChange={(e) => handleInputChange('depth', e.target.value)}
                  placeholder="Depth in mm"
                  min="0"
                />
          </div>
        </div>
          </div>
        )}

        <div className="form-group">
          <label>Overall Condition *</label>
          <div className="options-group">
            {['Good', 'Fair', 'Poor'].map(value => 
              renderOption(value, formData.overallCondition === value, () => handleOptionClick('overallCondition', value), `condition-${value}`)
            )}
          </div>
        </div>

        <div className="form-group">
          <label>Additional Notes</label>
          <textarea
            value={formData.conditionDetails.notes}
            onChange={(e) => handleInputChange('notes', e.target.value, 'conditionDetails')}
            className="text-input"
            rows="4"
          />
        </div>
      </section>

      <section className="form-section">
        <div className="photo-custom-container">
          <PhotoUpload
            onUpload={handlePhotoUpload}
            photoTypes={PHOTO_TYPES}
            uploadedPhotos={uploadedPhotos}
            isSurveySaved={isSurveySaved}
            surveyId={surveyId}
          />

          {!formData.customSection.label ? (
            <button
              type="button"
              className="add-custom-section-button"
              onClick={() => {
                setFormData(prev => ({
                  ...prev,
                  customSection: {
                    ...prev.customSection,
                    label: 'Custom Component'
                  }
                }));
              }}
            >
              + Add Custom Section
            </button>
          ) : (
            <>
              <div className="custom-section-header">
                <div className="custom-section-inputs">
                  <input
                    type="text"
                    className="text-input custom-component-name"
                    placeholder="Enter component name (e.g. Air transfer grille)"
                    value={formData.customSection.componentName}
                    onChange={(e) => {
                      setFormData(prev => ({
                        ...prev,
                        customSection: {
                          ...prev.customSection,
                          componentName: e.target.value
                        }
                      }));
                    }}
                  />
                  <input
                    type="text"
                    className="text-input custom-component-description"
                    placeholder="Enter description (e.g. ATG is defective)"
                    value={formData.customSection.description}
                    onChange={(e) => {
                      setFormData(prev => ({
                        ...prev,
                        customSection: {
                          ...prev.customSection,
                          description: e.target.value
                        }
                      }));
                    }}
                  />
                  {renderDefectPhotoUpload('customSection')}
                </div>
                <button
                  type="button"
                  className="remove-custom-section"
                  onClick={() => {
                    setFormData(prev => ({
                      ...prev,
                      customSection: {
                        label: '',
                        value: '',
                        defect: '',
                        customDefect: '',
                        componentName: '',
                        description: ''
                      }
                    }));
                  }}
                >
                  Remove
                </button>
              </div>
              <div className="form-group">
                <div className="options-group">
                  {['Yes', 'No', 'N/A'].map(value => 
                    renderOption(
                      value,
                      formData.customSection.value === value,
                      () => handleInputChange('value', value, 'customSection'),
                      `custom-section-${value}`
                    )
                  )}
                </div>
                {formData.customSection.value === 'No' && (
                  <div className="defect-input-section">
                    <div className="defect-header">
                      {renderDefectPhotoUpload('customSection')}
                      <select
                        value={formData.customSection.defect}
                        onChange={(e) => handleInputChange('defect', e.target.value, 'customSection')}
                        className="select-input"
                      >
                        <option value="">Select Defect</option>
                        <option value="damaged">Damaged</option>
                        <option value="missing">Missing</option>
                        <option value="custom">Other (specify)</option>
                      </select>
                    </div>
                    {formData.customSection.defect === 'custom' && (
                      <input
                        type="text"
                        className="text-input"
                        placeholder="Enter custom defect"
                        value={formData.customSection.customDefect || ''}
                        onChange={(e) => handleInputChange('customDefect', e.target.value, 'customSection')}
                      />
                    )}
                  </div>
                )}
              </div>
            </>
          )}
        </div>
      </section>

      <div className="form-actions">
        <button
          type="button"
          className="view-excel-button"
          onClick={handleViewExcel}
        >
          View Excel
        </button>
        <button type="button" className="cancel-button" onClick={handleCancel}>
          Cancel
        </button>
        <button 
          type="submit" 
          className={`save-button ${isSaving ? 'saving' : ''}`} 
          onClick={handleSave}
          disabled={isSaving}
        >
          {isSaving ? 'Saving...' : (isEditing ? 'Update Survey' : 'Save Survey')}
        </button>
      </div>
    </div>
  );
};

export default FireDoorSurveyForm; 